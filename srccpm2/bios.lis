Z80/8080-Macro-Assembler  Release 2.0

LOC   OBJECT CODE   LINE   STMT SOURCE CODE
                       1      1 ;	8080 CBIOS for Arduino 8080
                       2      2 ;
                       3      3 ;	Copyright (C) 2024 by Udo Munk
                       4      4 ;
0040  =                5      5 MSIZE	EQU	64		;CP/M memory size in kilobytes
                       6      6 ;
                       7      7 ;	"bias" is address offset from 3400H for memory systems
                       8      8 ;	than 16K (referred to as "b" throughout the text).
                       9      9 ;
b000  =               10     10 BIAS	EQU	(MSIZE-20)*1024
e400  =               11     11 CCP	EQU	3400H+BIAS	;base of ccp
ec06  =               12     12 BDOS	EQU	CCP+806H	;base of bdos
fa00  =               13     13 BIOS	EQU	CCP+1600H	;base of bios
002c  =               14     14 NSECTS	EQU	(BIOS-CCP)/128	;warm start sector count
0004  =               15     15 CDISK	EQU	0004H		;current disk number 0=A,...,15=P
0003  =               16     16 IOBYTE	EQU	0003H		;Intel I/O byte
0040  =               17     17 FDCCMD	EQU	0040H		;FDC command bytes
0000  =               18     18 DDTRK	EQU	0		;offset for track
0001  =               19     19 DDSEC	EQU	1		;offset for sector
0002  =               20     20 DDLDMA	EQU	2		;offset for DMA address low
0003  =               21     21 DDHDMA	EQU	3		;offset for DMA address high
                      22     22 ;
                      23     23 ;	I/O ports
                      24     24 ;
0000  =               25     25 CONSTA	EQU	0		;console status port
0001  =               26     26 CONDAT	EQU	1		;console data port
0004  =               27     27 FDC	EQU	4		;port for the FDC
                      28     28 ;
                      29     29 	.8080
                      30     30 	ORG	BIOS		;origin of BIOS
                      31     31 ;
                      32     32 ;	jump vector for individual subroutines
                      33     33 ;
fa00  c3 ae fa        34     34 	JMP	BOOT		;cold boot
fa03  c3 d2 fa        35     35 WBE	JMP	WBOOT		;warm start
fa06  c3 40 fb        36     36 	JMP	CONST		;console status
fa09  c3 4b fb        37     37 	JMP	CONIN		;console character in
fa0c  c3 54 fb        38     38 	JMP	CONOUT		;console character out
fa0f  c3 60 fb        39     39 	JMP	LIST		;list character out
fa12  c3 61 fb        40     40 	JMP	PUNCH		;punch character out
fa15  c3 62 fb        41     41 	JMP	READER		;reader character in
fa18  c3 65 fb        42     42 	JMP	HOME		;move disk head to home position
fa1b  c3 6a fb        43     43 	JMP	SELDSK		;select disk drive
fa1e  c3 81 fb        44     44 	JMP	SETTRK		;set track number
fa21  c3 86 fb        45     45 	JMP	SETSEC		;set sector number
fa24  c3 8b fb        46     46 	JMP	SETDMA		;set dma address
fa27  c3 94 fb        47     47 	JMP	READ		;read disk sector
fa2a  c3 9c fb        48     48 	JMP	WRITE		;write disk sector
fa2d  c3 5e fb        49     49 	JMP	LISTST		;list status
fa30  c3 a9 fb        50     50 	JMP	SECTRAN		;sector translate
                      51     51 ;
                      52     52 ;	data tables
                      53     53 ;
fa33  36 34           54     54 SIGNON	DB	MSIZE / 10 + '0',MSIZE MOD 10 + '0'
fa35  4b 20 43 50     55     55 	DB	'K CP/M 2.2 VERS B01',13,10,0
fa39  2f 4d 20 32     55     56
fa3d  2e 32 20 56     55     57
fa41  45 52 53 20     55     58
fa45  42 30 31 0d     55     59
fa49  0a 00           55     60
fa4b  0d 0a 42 4f     56     61 BOOTERR	DB	13,10,'BOOT ERROR',13,10,0
fa4f  4f 54 20 45     56     62
fa53  52 52 4f 52     56     63
fa57  0d 0a 00        56     64
                      57     65 ;
                      58     66 ;	disk parameter header for disk 0
fa5a  7a fa 00 00     59     67 DPBASE	DW	TRANS,0000H
fa5e  00 00 00 00     60     68 	DW	0000H,0000H
fa62  b2 fb 94 fa     61     69 	DW	DIRBF,DPBLK
fa66  70 fc 32 fc     62     70 	DW	CHK00,ALL00
                      63     71 ;	disk parameter header for disk 1
fa6a  7a fa 00 00     64     72 	DW	TRANS,0000H
fa6e  00 00 00 00     65     73 	DW	0000H,0000H
fa72  b2 fb 94 fa     66     74 	DW	DIRBF,DPBLK
fa76  80 fc 51 fc     67     75 	DW	CHK01,ALL01
                      68     76 ;
                      69     77 ;	sector translate table for IBM 8" SD disks
fa7a  01 07 0d 13     70     78 TRANS	DB	1,7,13,19	;sectors 1,2,3,4
fa7e  19 05 0b 11     71     79 	DB	25,5,11,17	;sectors 5,6,7,8
fa82  17 03 09 0f     72     80 	DB	23,3,9,15	;sectors 9,10,11,12
fa86  15 02 08 0e     73     81 	DB	21,2,8,14	;sectors 13,14,15,16
fa8a  14 1a 06 0c     74     82 	DB	20,26,6,12	;sectors 17,18,19,20
fa8e  12 18 04 0a     75     83 	DB	18,24,4,10	;sectors 21,22,23,24
fa92  10 16           76     84 	DB	16,22		;sectors 25,26
                      77     85 ;
                      78     86 ;	disk parameter block for IBM 8" SD disks
fa94  1a 00           79     87 DPBLK	DW	26		;sectors per track
fa96  03              80     88 	DB	3		;block shift factor
fa97  07              81     89 	DB	7		;block mask
fa98  00              82     90 	DB	0		;extent mask
fa99  f2 00           83     91 	DW	242		;disk size-1
fa9b  3f 00           84     92 	DW	63		;directory max
fa9d  c0              85     93 	DB	192		;alloc 0
fa9e  00              86     94 	DB	0		;alloc 1
fa9f  10 00           87     95 	DW	16		;check size
faa1  02 00           88     96 	DW	2		;track offset
                      89     97 ;
                      90     98 ;	print a message to the console
                      91     99 ;	pointer to string in hl
                      92    100 ;
faa3  7e              93    101 PRTMSG	MOV	A,M		;get next message byte
faa4  b7              94    102 	ORA	A		;is it zero?
faa5  c8              95    103 	RZ			;yes, done
faa6  4f              96    104 	MOV	C,A		;no, print character on console
faa7  cd 54 fb        97    105 	CALL	CONOUT
faaa  23              98    106 	INX	H		;and do next
faab  c3 a3 fa        99    107 	JMP	PRTMSG
                     100    108 ;
                     101    109 ;	cold start
                     102    110 ;
faae  31 80 00       103    111 BOOT	LXI	SP,80H		;use space below buffer for stack
fab1  21 33 fa       104    112 	LXI	H,SIGNON	;print signon
fab4  cd a3 fa       105    113 	CALL	PRTMSG
fab7  af             106    114 	XRA	A		;zero in the accumulator
fab8  32 04 00       107    115 	STA	CDISK		;select disk drive 0
fabb  32 b1 fb       108    116 	STA	DSKNO
fabe  32 03 00       109    117 	STA	IOBYTE		;setup IOBYTE
fac1  3e 10          110    118 	MVI	A,10H		;setup FDC command
fac3  d3 04          111    119 	OUT	FDC
fac5  3e 40          112    120 	MVI	A,FDCCMD AND 0FFH
fac7  d3 04          113    121 	OUT	FDC
fac9  3e 00          114    122 	MVI	A,FDCCMD SHR 8
facb  d3 04          115    123 	OUT	FDC
facd  37             116    124 	STC			;flag for cold start
face  3f             117    125 	CMC
facf  c3 1c fb       118    126 	JMP	GOCPM		;initialize and go to CP/M
                     119    127 ;
                     120    128 ;	warm start
                     121    129 ;
fad2  31 80 00       122    130 WBOOT	LXI	SP,80H		;use space below buffer for stack
fad5  0e 00          123    131 	MVI	C,0		;select disk 0
fad7  cd 6a fb       124    132 	CALL	SELDSK
fada  cd 65 fb       125    133 	CALL	HOME		;go to track 0
fadd  06 2c          126    134 	MVI	B,NSECTS	;B counts # of sectors to load
fadf  0e 00          127    135 	MVI	C,0		;C has the current track #
fae1  16 02          128    136 	MVI	D,2		;D has the next sector to load
fae3  21 00 e4       129    137 	LXI	H,CCP		;base of CP/M
fae6  c5             130    138 LOAD1	PUSH	B		;save sector count and current track
fae7  d5             131    139 	PUSH	D		;save next sector to read
fae8  e5             132    140 	PUSH	H		;save DMA address
fae9  4a             133    141 	MOV	C,D		;get sector address to C
faea  cd 86 fb       134    142 	CALL	SETSEC		;set sector address
faed  c1             135    143 	POP	B		;recall DMA address to BC
faee  c5             136    144 	PUSH	B		;and replace on stack for later recall
faef  cd 8b fb       137    145 	CALL	SETDMA		;set DMA address from BC
faf2  cd 94 fb       138    146 	CALL	READ		;read sector
faf5  b7             139    147 	ORA	A		;any errors?
faf6  ca 00 fb       140    148 	JZ	LOAD2		;no, continue
faf9  21 4b fa       141    149 	LXI	H,BOOTERR	;otherwise print message
fafc  cd a3 fa       142    150 	CALL	PRTMSG
faff  76             143    151 	HLT			;and halt the machine
fb00  e1             144    152 LOAD2	POP	H		;recall DMA address
fb01  11 80 00       145    153 	LXI	D,128		;DMA = DMA + 128
fb04  19             146    154 	DAD	D		;next DMA address now in HL
fb05  d1             147    155 	POP	D		;recall sector address
fb06  c1             148    156 	POP	B		;recall # of sectors remaining
fb07  05             149    157 	DCR	B		;sectors = sectors - 1
fb08  37             150    158 	STC			;flag for warm start
fb09  ca 1c fb       151    159 	JZ	GOCPM		;transfer to CP/M if all loaded
fb0c  14             152    160 	INR	D		;next sector
fb0d  7a             153    161 	MOV	A,D		;sector = 27 ?
fb0e  fe 1b          154    162 	CPI	27
fb10  da e6 fa       155    163 	JC	LOAD1		;no, continue
fb13  16 01          156    164 	MVI	D,1		;else begin with sector 1 on next track
fb15  0c             157    165 	INR	C
fb16  cd 81 fb       158    166 	CALL	SETTRK
fb19  c3 e6 fa       159    167 	JMP	LOAD1		;for another sector
fb1c  3e c3          160    168 GOCPM	MVI	A,0C3H		;C3 is a JMP instruction
fb1e  32 00 00       161    169 	STA	0		;for jmp to wboot
fb21  21 03 fa       162    170 	LXI	H,WBE		;WBOOT entry point
fb24  22 01 00       163    171 	SHLD	1		;set address for JMP at 0
fb27  32 05 00       164    172 	STA	5		;for JMP to BDOS
fb2a  21 06 ec       165    173 	LXI	H,BDOS		;BDOS entry point
fb2d  22 06 00       166    174 	SHLD	6		;set address for JMP at 5
fb30  01 80 00       167    175 	LXI	B,80H		;default dma address is 80H
fb33  cd 8b fb       168    176 	CALL	SETDMA
fb36  3a 04 00       169    177 	LDA	CDISK		;get current disk number
fb39  4f             170    178 	MOV	C,A		;send to the CCP
fb3a  da 03 e4       171    179 	JC	CCP+3		;go to CCP warm start
fb3d  c3 00 e4       172    180 	JMP	CCP		;go to CCP cold start
                     173    181 ;
                     174    182 ;	console status, return 0FFH if character ready, 00H if not
                     175    183 ;
fb40  db 00          176    184 CONST	IN	CONSTA		;get console status
fb42  0f             177    185 	RRC			;test bit 0
fb43  da 49 fb       178    186 	JC	CONST1		;not ready
fb46  3e ff          179    187 	MVI	A,0FFH		;ready, set flag
fb48  c9             180    188 	RET
fb49  af             181    189 CONST1	XRA	A		;zero A
fb4a  c9             182    190 	RET
                     183    191 ;
                     184    192 ;	console input character into register A
                     185    193 ;
fb4b  db 00          186    194 CONIN	IN	CONSTA		;get console status
fb4d  0f             187    195 	RRC			;test bit 0
fb4e  da 4b fb       188    196 	JC	CONIN		;not ready
fb51  db 01          189    197 	IN	CONDAT		;get character from console
fb53  c9             190    198 	RET
                     191    199 ;
                     192    200 ;	console output
                     193    201 ;
fb54  db 00          194    202 CONOUT	IN	CONSTA		;get status
fb56  07             195    203 	RLC			;test bit 7
fb57  da 54 fb       196    204 	JC	CONOUT		;wait until transmitter ready
fb5a  79             197    205 	MOV	A,C		;get character into accumulator
fb5b  d3 01          198    206 	OUT	CONDAT		;send to console
fb5d  c9             199    207 	RET
                     200    208 ;
                     201    209 ;	printer status, return 0FFH if character ready, 00H if not
                     202    210 ;
fb5e  af             203    211 LISTST	XRA	A		;we have no printer
fb5f  c9             204    212 	RET			;so never ready
                     205    213 ;
                     206    214 ;	line printer output
                     207    215 ;
fb60  c9             208    216 LIST	RET			;we have no printer
                     209    217 ;
                     210    218 ;	punch character from register C
                     211    219 ;
fb61  c9             212    220 PUNCH	RET			;we have no puncher
                     213    221 ;
                     214    222 ;	read character into register A from reader
                     215    223 ;
fb62  3e 1a          216    224 READER	MVI	A,01AH		;we have no reader
fb64  c9             217    225 	RET			;so return CTL-Z
                     218    226 ;
                     219    227 ;	move to track 0 position on current disk
                     220    228 ;
fb65  0e 00          221    229 HOME	MVI	C,0		;select track 0
fb67  c3 81 fb       222    230 	JMP	SETTRK
                     223    231 ;
                     224    232 ;	select disk given by register C
                     225    233 ;
fb6a  21 00 00       226    234 SELDSK	LXI	H,0		;error return code
fb6d  79             227    235 	MOV	A,C		;get disk # to accumulator
fb6e  fe 02          228    236 	CPI	2		;disk drive < 2 ?
fb70  da 74 fb       229    237 	JC	SEL1
fb73  c9             230    238 	RET			;no, return with error
fb74  32 b1 fb       231    239 SEL1	STA	DSKNO		;save disk #
fb77  69             232    240 	MOV	L,C		;HL = disk #
fb78  29             233    241 	DAD	H		;*2
fb79  29             234    242 	DAD	H		;*4
fb7a  29             235    243 	DAD	H		;*8
fb7b  29             236    244 	DAD	H		;*16 (size of each header)
fb7c  11 5a fa       237    245 	LXI	D,DPBASE
fb7f  19             238    246 	DAD	D		;HL=.DPBASE(DISKNO*16)
fb80  c9             239    247 	RET
                     240    248 ;
                     241    249 ;	set track given by register C
                     242    250 ;
fb81  79             243    251 SETTRK	MOV	A,C		;get to accumulator
fb82  32 40 00       244    252 	STA	FDCCMD+DDTRK	;set in FDC command
fb85  c9             245    253         RET
                     246    254 ;
                     247    255 ;	set sector given by register C
                     248    256 ;
fb86  79             249    257 SETSEC	MOV	A,C		;get to accumulator
fb87  32 41 00       250    258 	STA     FDCCMD+DDSEC	;set in FDC command
fb8a  c9             251    259         RET
                     252    260 ;
                     253    261 ;	set DMA address given by registers B and C
                     254    262 ;
fb8b  79             255    263 SETDMA	MOV	A,C		;low order address
fb8c  32 42 00       256    264 	STA	FDCCMD+DDLDMA	;set in FDC command
fb8f  78             257    265 	MOV	A,B		;high order address
fb90  32 43 00       258    266 	STA	FDCCMD+DDHDMA	;set in FDC command
fb93  c9             259    267         RET
                     260    268 ;
                     261    269 ;	perform read operation
                     262    270 ;
fb94  3a b1 fb       263    271 READ	LDA     DSKNO		;get disk #
fb97  f6 20          264    272 	ORI	20H		;mask in read command
fb99  c3 a4 fb       265    273         JMP     DOIO            ;do I/O operation
                     266    274 ;
                     267    275 ;	perform write operation
                     268    276 ;
fb9c  3a b1 fb       269    277 WRITE	LDA	DSKNO		;get disk #
fb9f  f6 40          270    278 	ORI	40H		;mask in write command
fba1  c3 a4 fb       271    279 	JMP	DOIO		;do I/O operation
                     272    280 ;
                     273    281 ;	perform read/write I/O
                     274    282 ;
fba4  d3 04          275    283 DOIO	OUT	FDC		;ask FDC to execute the command
fba6  db 04          276    284 	IN	FDC		;get status from FDC
fba8  c9             277    285         RET
                     278    286 ;
                     279    287 ;	translate the sector given by BC using
                     280    288 ;	the translation table given by DE
                     281    289 ;
fba9  eb             282    290 SECTRAN	XCHG			;HL=.TRANS
fbaa  09             283    291 	DAD	B               ;HL=.TRANS(SECTOR)
fbab  eb             284    292 	XCHG
fbac  1a             285    293 	LDAX	D
fbad  6f             286    294 	MOV	L,A		;L=TRANS(SECTOR)
fbae  26 00          287    295 	MVI	H,0		;HL=TRANS(SECTOR)
fbb0  c9             288    296 	RET			;with value in HL
                     289    297 ;
                     290    298 ;	The remainder of the CBIOS is reserved uninitialized
                     291    299 ;	data area, and does not need to be part of the system
                     292    300 ;	memory image. The space must be available, however,
                     293    301 ;	between "BEGDAT" and "ENDDAT".
                     294    302 ;
fbb1  =              295    303 BEGDAT	EQU	$		;begin of data area
                     296    304 ;
fbb1                 297    305 DSKNO	DS	1		;selected disk
                     298    306 ;
fbb2                 299    307 DIRBF	DS	128		;scratch directory area
fc32                 300    308 ALL00	DS	31		;allocation vector 0
fc51                 301    309 ALL01	DS	31		;allocation vector 1
fc70                 302    310 CHK00	DS	16		;check vector 0
fc80                 303    311 CHK01	DS	16		;check vector 1
                     304    312 ;
fc90  =              305    313 ENDDAT	EQU	$		;end of data area
00df  =              306    314 DATSIZ	EQU	$-BEGDAT	;size of data area
                     307    315 ;
fc90                 308    316 	END			;of CBIOS

Symbol table

ALL00   fc32    ALL01   fc51    BDOS    ec06    BEGDAT  fbb1    BIAS    b000 
BIOS    fa00    BOOT    faae    BOOTERR fa4b    CCP     e400    CDISK   0004 
CHK00   fc70    CHK01   fc80    CONDAT  0001    CONIN   fb4b    CONOUT  fb54 
CONST   fb40    CONST1  fb49    CONSTA  0000    DATSIZ  00df*   DDHDMA  0003 
DDLDMA  0002    DDSEC   0001    DDTRK   0000    DIRBF   fbb2    DOIO    fba4 
DPBASE  fa5a    DPBLK   fa94    DSKNO   fbb1    ENDDAT  fc90*   FDC     0004 
FDCCMD  0040    GOCPM   fb1c    HOME    fb65    IOBYTE  0003    LIST    fb60 
LISTST  fb5e    LOAD1   fae6    LOAD2   fb00    MSIZE   0040    NSECTS  002c 
PRTMSG  faa3    PUNCH   fb61    READ    fb94    READER  fb62    SECTRAN fba9 
SEL1    fb74    SELDSK  fb6a    SETDMA  fb8b    SETSEC  fb86    SETTRK  fb81 
SIGNON  fa33    TRANS   fa7a    WBE     fa03    WBOOT   fad2    WRITE   fb9c 
